---
title: "Tidyverse"
subtitle: "Manipulación y transformación de datos en R"
author: "Lucía Coudet"
date: "Septiembre de 2018"
output:
  beamer_presentation:
    theme: "Frankfurt"
    colortheme: "default"
    fonttheme: "structurebold"
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
library(tidyverse)
library(gridExtra)
library(kableExtra)
```

# Dplyr basics

Existen \textbf{6 funciones} que nos permiten resolver una amplia gama de desafíos en lo que concierne a manipulación de datos:

##

-  Levantar observaciones por sus valores: `filter()`
-  Reordenar filas: `arrange()`
-  Levantar variables por sus nombres: `select()`
-  Crear nuevas variables a partir de existentes `mutate()` (y `transmutate()`)
-  Agrupar observarciones con `group_by()`
-  Generar medidas de resúmen a partir de distintos valores: `summarise()`
 

# Tidy data 

Lamentablemente los datos suelen venir desordenados, entre otras cosas debido a que por lo general no se levantan desde una lógica adecuada para nosotros, los que los analizamos. El paquete `tidyr` nos ofrece varias funciones útiles para ordenarlos.

##

-  Cuando las columnas son niveles de una variable las reunimos en una sola con `gather()`.
- `spread()`: es el opuesto de `gather()`.
- Si queremos separar los valores de una variable lo hacemos con `separate()`.

# Otras funciones de dplyr: Joins 

Y si queremos `matchear` (unir) los datos de la base en la cuál estamos trabajando con datos de otra, solo precisamos una variable de matcheo y una de la siguientes funciones que más se adecue a nuestro deseo, las cuales las podemos pensar como operaciones entre conjuntos:

##

- `full_join()`: unión de conjuntos.
- `inner_join()`: intersección de conjuntos.
- `left_join()`: Se queda con todas las filas de la primera base que se le pasa.
- `right_join()`: Se queda con todas las filas de la segunda base que se le pasa.

\textbf{\underline{Observación}:} Se generan`Na's` para el caso en que la variable de matcheo presenta valores dispares entre las bases que queremos joinear, según la función que seleccionemos. 

# Base de datos utilizada

Utilizamos una base de datos extraída del \textbf{Estudio Longitudinal de Bienestar en el Uruguay} llevado a cabo por el Instituto de Economía (iecon), el cual consiste en un relevamiento longitudinal representativo de los niños que concurren al sistema de educación primaria pública. 

Se recoge información  referente a múltiples dimensiones del bienestar de los niños en la muestra así como también del resto de los integrantes de sus hogares, entre los que se destacan: 

-  situación nutricional.
-  habilidades cognitivas y no cognitivas.
-  imaginación; razonamiento y sentimientos. 
-  actividades de ocio einteracción social.
-  logros educativos.
-  ingresos.
-  calidad de la vivienda y bienestar subjetivo, entre otros.

# Relevamiento de información

## Tres "Olas" 
-  La primera realizada en el año 2004 a 3000 niños del primer grado de escuela.
-  La segunda realizada en el año 2005 a los mismos niños analizados en la primera ola.
-  La tercera realizada en el año 2012 a los mismo niños analizados en la primera ola.

## Las olas contienen bases
-  De \textbf{personas}, con información referente al niño y personas del hogar donde reside).
-  De \textbf{hogares}, con información más enfocada al niño, sus capacidades de relacionamiento, emociones, amigos, etc.

\textbf{Utilizamos la base de personas correspondiente a la Tercer Ola de relevamiento}

# Qué buscamos?

##

AGREGAR


# Paso 1: Leemos los datos

Los datos están en un archivo .csv por lo que utilizamos la función `read_csv` del paquete `readr`.

```{r}
personas <- readr::read_csv('Personas_Ola_3.csv')
dim(personas)
```

## Queremos quedarnos solo con algunas variables:

-  Sexo.
-  Edad.
-  Situación conyugal.
-  Nivel educativo que cursa o cursó.
-  Ingresos.
-  Ocupación principal / Tareas.
-  Acceso a planes de ayuda económica o alimenticia

# Seleccionamos columnas con select()

Dos opciones: 

- Si queremos seleccionar una variable ponemos su nombre.
-  Si queremos sacar una variable ponemos su nombre con un signo de `-` adelante.
-  Si queremos seleccionar (o sacar) un un rango seguido de columnas, por ej de la A a la F, lo hacemos con `A:F`, o bien `-(A:F)`.

```{r}
personas <- personas %>% select(-h13, -h11, -(h9b1:h9b8), 
                                -(h4:h5), -h2, -h1, -g8b, 
                                -g8a, -g7, -g3, -g2b, -f1)
```

# Filtramos observaciones con filter() y hacemos resúmenes por grupos

La variable `nper` etiqueta con un número a cada miembro del hogar. Sospechamos que cuando toma valor 1 se trata del niño seleccionado en la muestra.

Estos niños deberían tener todos menos de 20 años, por lo que filtramos la base por edad y agrupamos según `nper`.

```{r}
edades <- personas %>% filter(f11 < 20) %>% 
      group_by(nper) %>% 
      summarise(conteo = n()) 
```

# Filtramos observaciones con filter() y hacemos resúmenes por grupos

```{r, echo=FALSE}
knitr::kable(head(edades, 6))
```

`nper == 1` contiene 2137 observaciones, lo cuál coincide con la cantidad de niños en la muestra.

Pero nos gustaría ordenar esa tabla según `conteo` en forma decreciente.
Lo hacemos con la función `arrange()`.

# Ordenamos filas con arrange()

```{r}
edades <- arrange(edades, desc(conteo))
```

```{r, echo=FALSE}
knitr::kable(head(edades, 8))
```
